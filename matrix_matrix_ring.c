/*Γράφω πρώτα τις οδηγίες προς τον προμεταγλωττιστή της C,
οι οποίες εκτελούνται από αυτόν ένα στάδιο πριν αρχίσει η κανονική μεταγλώττιση*/

//Η οδηγία #include επιβάλλει στον προμεταγλωττιστή να συμπεριλάβει κάποιο αρχείο κεφαλίδας (αρχείο που περιέχει συναρτήσεις βιβλιοθήκης)
#include <stdio.h> //Βιβλιοθήκη εισόδου/εξόδου.
#include <stdlib.h> //Βιβλιοθήκη για την εκχώρηση μνήμης, τον έλεγχο διεργασιών κτλπ.
#include <stdbool.h> //Βιβλιοθήκη για τύπους και τιμές boolean.
#include <math.h> //Βιβλιοθήκη μαθηματικών. 
#include <mpi.h> //Βιβλιοθήκη Message Passing Interface (MPI) για παράλληλους υπολογισμούς.


//Η οδηγία #define ορίζει ένα αναγνωριστικό και ένα σύνολο χαρακτήρων που θα αντικαταστήσει αυτό το αναγνωριστικό
// Ορίζω το μέγεθος του πίνακα (Ν), αν δεν έχει προκαθοριστεί
#ifndef N //Εάν η σταθερά N δεν έχει οριστεί, προχωράμε στην επόμενη γραμμή.
#define N 16 //Ορίζω το N ως 16.
#endif

// Ορίζω την ριζική διεργασία για τις λειτουργίες MPI
#define _ROOT 0  

//Όνομα αρχείου εξόδου για το μητρώο A που προκύπτει
#ifndef OUT_FILE_NAME //Εάν η σταθερά OUT_FILE_NAME δεν έχει οριστεί, προχωράμε στην επόμενη γραμμή.
#define OUT_FILE_NAME "outputA.txt" //Ορίζω το OUT_FILE_NAME ως outputA.txt.
#endif


//MPI communicator για την τοπολογία δακτυλίου - ring topology
MPI_Comm ring_comm; 

// Δηλώνω την συνάρτηση για την δημιουργία δισδιάστατου μητρώου.
int** createMatrix(int m, int n);

//Εκχωρώ μνήμη για έναν δισδιάστατο πίνακα.
int** createMatrix(int m, int n) {

    /*Η συνάρτηση void *malloc(unsigned int size), δεσμεύει από το σώρό ένα τμήμα μνήμης (μπλοκ-πλοκάδα), μεγέθους σε bytes, όσο η τιμή της
      παραμέτρου size και επιστρέφει ως τιμή τη διεύθυνση της πρώτης θέσης μνήμης αυτού του μπλοκ */

    //Δημιουργώ δυναμικά έναν πίνακα δεικτών σε ακέραιους αριθμούς χρησιμοποιώντας τον διπλό δείκτη, 
    //(δείκτης που δείχνει σε έναν δείκτη που δείχνει ακέραιο τύπο). 
    //Μόλις τον δημιουργήσω μπορώ να εκχωρήσω δυναμικά για κάθε γραμμή.
    //Άρα ο πίνακας δεικτών matrix_2d θα κρατήσει τις διευθύνσεις των δυναμικά εκχωρημένων γραμμών (πίνακες ακεραίων) στον δισδιάστατο μητρώο.
    int** matrix_2d = (int**)malloc(m * sizeof(int*)); 
    
    //Δεσμεύω ένα μπλοκ μνήμης μεγέθους m*n και αποκτώ πρόσβαση στα στοιχεία του χρησιμοποιώντας απλό δείκτη σε έναν ακέραιο. 
    //Μετατροπή του δείκτη void που επιστρέφει η συνάρτηση malloc σε δείκτη προς δεδομένα τύπου int.
    int* matrix_1d = (int*)malloc(m * n * sizeof(int));
    
    //Καθορίζω την σχέση μεταξύ του matrix_2d και του matrix_1d
    //Το matrix_1d είναι ένα μπλοκ μνήμης με στοιχεία m * n.
    //Το matrix_2d είναι ένας πίνακας δεικτών, όπου κάθε δείκτης δείχνει σε μια συγκεκριμένη γραμμή μέσα σε αυτό το μπλοκ.
    //Με τον βρόγχο διασφαλίζω ότι κάθε δείκτης γραμμής στο matrix_2d δείχνει στη πρώτη θέση μνήμης της αντίστοιχης γραμμής στο matrix_1d.
    for (int i = 0; i < m; i++) {
        

        // Για κάθε γραμμή (με ευρετήριο i) στον δισδιάστατο πίνακα:
        // Το matrix_2d[i] είναι ένας δείκτης σε έναν ακέραιο (δείκτης γραμμής).
        // Το &matrix_1d[i * n] υπολογίζει τη διεύθυνση της πρώτης θέσης μνήμης (έναρξης) της αντίστοιχης γραμμής στον 1D.
        // Εκχωρώ το &matrix_1d[i * n] στο matrix_2d[i], ώστε ο δείκτης γραμμής στο matrix_2d να δείχνει τη σωστή θέση μνήμης στον πίνακα 1D.
        // Ουσιαστικά, κάθε δείκτης γραμμής στο 2D δείχνει στη κατάλληλη θέση μνήμης στον 1D.
        matrix_2d[i] = &matrix_1d[i * n];

    }
    return matrix_2d; //Επιστρέφω τον δυναμικά εκχωρημένο δισδιάστατο πίνακα.
}

// Συνάρτηση Main 
int main(int argc, char* argv[])
{
   //Δηλώνω ακέραιες μεταβλητές
    int my_rank, ierr, num_procs; 
    
    //Δημιουργώ την διεργασία
    //Αρχικοποιώ τον υπολογισμό και εκκινώ τη βιβλιοθήκη MPI.
    //Επιτρέπω στο πρόγραμμα να χρησιμοποιεί συναρτήσεις MPI:
    //Για επικοινωνία μεταξύ διεργασιών και για παράλληλη εκτέλεση/επεξεργασία.
    //Πρέπει να καλείται από κάθε διεργασία MPI ακριβώς μια φορά.
    ierr = MPI_Init(&argc, &argv);
   

    //Επιστρέφω το αναγνωριστικό/αριθμό της διεργασίας.
    //Το MPI_COMM_WORLD είναι σταθερά που ορίζει έναν communicator που περιέχει όλες τις διεργασίες 
    //και μέσω του οποίου ανακτώ την κατάταξη της τρέχουσας διεργασίας.
    //Η κατάταξη είναι μια ακέραια τιμή που προσδιορίζει μοναδικά κάθε διεργασία στον communicator.
    //Ο αριθμός της τρέχουσας διεργασίας (κατάταξή της) επιστρέφεται και αποθηκεύεται στο my_rank.
    ierr = MPI_Comm_rank(MPI_COMM_WORLD, &my_rank);

    //Επιστρέφω το πλήθος των διεργασιών που συμμετέχουν στον communicator.
    //Το πλήθος των διεργασιών αποθηκεύεται στη μεταβλητή num_procs.
    ierr = MPI_Comm_size(MPI_COMM_WORLD, &num_procs);
    
    // Ρύθμιση τοπολογίας δακτυλίου
    int dim[1] = { num_procs }; // Μονοδιάστατη κυκλική δομή, με το συνολικό πλήθος των διεργασιών.
    int period[1] = { 1 }; // Η περιοδικότητα έχει οριστεί σε 1 για συνδέσεις περιτυλίγματος. Δηλαδή υπάρχουν ανακυκλώσεις στα ακραία στοιχεία επεξεργασίας.
    int coords[1]; // Πίνακας για αποθήκευση της συντεταγμένης της τρέχουσας διεργασίας στον δακτύλιο.

    // Δημιουργία της τοπολογίας δακτυλίου
    //Ο νέος communicator δέχεται ως όρισματα τις πληροφορίες της τοπολογίας δακτυλίου:
    //MPI_COMM_WORLD - Ο υπάρχον communicator, αντιπροσωπεύει όλες τις διεργασίες στο παράλληλο πρόγραμμα.
    //1 - Η διάσταση του πλέγματος.
    //dim - Πίνακας που περιέχει το πλήθος διεργασιών.
    //period - Πίνακας που προσδιορίζει εάν επιτρέπονται συνδέσεις περιτυλίγματος (περιοδικότητα) σε κάθε διάσταση.
    //reorder - Σημαία που υποδεικνύει εάν το MPI μπορεί να αναδιατάξει τις διεργασίες για να βελτιώσει την απόδοση. Με 0 δεν αναδιατάσσονται.
    //&ring_comm - Διεύθυνση της μεταβλητής στην οποία θα αποθηκευτεί ο νέος communicator.
    MPI_Cart_create(MPI_COMM_WORLD, 1, dim, period, 0, &ring_comm);
    
    // Παίρνω το rank και τις συντεταγμένες της τρέχουσας διεργασίας στο δακτύλιο.
    
    //Ανακτώ την το αναγνωριστικό της τρέχουσας διεργασίας εντός του communicator, ring_comm και την αποθηκεύω στην μεταβλητή my_rank.
    MPI_Cart_rank(ring_comm, coords, &my_rank);

    //Αποθηκεύω τις συντεταγμένες της διεργασίας με αναγνωριστικό my_rank εντός communicator στον πίνακα coords.
    //Πλέον ο πίνακας coords περιέχει την θέση της τρέχουσας διεργασίας μέσα στην τοπολογία.
    MPI_Cart_coords(ring_comm, my_rank, 1, coords);
    

    // Δημιουργώ τις μεταβλητές για να διατηρήσω τα ranks των διεργασιών προέλευσης και προορισμού στην τοπολογία.
    int source, dest;

    // Καθορίζω τις διεργασίες προέλευσης και προορισμού για την τρέχουσα διεργασία.
    // Επιστρέφω την κατάταξη των διεργασιών προέλευσης (αποστολή δεδομένων) και προορισμού (λήψη δεδομένων) κατά τη μετατόπιση δεδομένων 
    //κατά μήκος του δακτυλίου.
    // 0: Η διάσταση κατά μήκος της οποίας εμφανίζεται η μετατόπιση (0 για τη γραμμή, 1 για τη στήλη). 
    // Θέλω να στείλω δεδομένα σε μια γειτονική διεργασία στην ίδια γραμμή,γι'αυτό χρησιμοποιώ μια μετατόπιση κατά μήκος της διάστασης 0.
    // Στη συνέχεια, υπολογίζω τις τάξεις των διεργασιών που βρίσκονται ένα βήμα προς τα αριστερά και τα δεξιά (υποθέτοντας μετατόπιση 1), 
    // 1: Αυτός είναι ο αριθμός των θέσεων που θα μετακινηθεί μια διεργασία στο πλέγμα. 
    // Για παράδειγμα, η μετατόπιση 1 σημαίνει ότι η διεργασία θα μετακινηθεί στον άμεσο γείτονά της.
    // Με μετατόπιση 1 και περετύλιξη, το πλέγμα είναι κυκλικό, οπότε 
    // μια μετατόπιση πέρα από την άκρη θα τυλιχτεί στην άλλη πλευρά του πλέγματος.
    // Οι source και dest είναι μεταβλητές όπου αποθηκεύονται τα rank των διεργασιών προέλευσης και προορισμού.
    MPI_Cart_shift(ring_comm, 0, 1, &source, &dest);
    


    //Ξεκινώ την χρονομέτρηση της εκτέλεσης - ενεργοποιώ το υποθετικό χρονόμετρο
    //Αποθηκεύω την επιστρεφόμενη τιμή χρόνου στη μεταβλητή startTime, ώστε
    //αργότερα να υπολογίσω τη διάρκεια της εκτέλεσης αφαιρώντας την ώρα έναρξης από την ώρα λήξης.
    double startTime = MPI_Wtime(); 
    
    //Εκχώρηση μνήμης για τους δισδιάστατους πίνακες B και C
    int** B = createMatrix(N, N);
    int** C = createMatrix(N, N);
    int** A = NULL;  //Ο πίνακας Α θα χρησιμοποιηθεί μόνο από τη ριζική διεργασία.


    //Η ριζική διεργασία αρχικοποιεί τους πίνακες B και C με τιμές που παρέχει ο χρήστης
    //Ελέγχω εάν η τρέχουσα διεργασία (my_rank) είναι η ριζική διεργασία (my_rank=0).
    if (my_rank == _ROOT)
    {
         A = createMatrix(N, N); //Εκχωρώ μνήμη για τον πίνακα A, που χρησιμοποιείται μόνο από την ριζική διεργασία.


        //Ζητάω από τον χρήστη να εισάγει τιμές για τον πίνακα B και C.
        printf("Please provide %d x %d Matrix B\n", N, N);

        //Ο χρήστης εισάγει τιμές για κάθε στοιχείο του πίνακα Β, όμοια και για τον C.
        //Αρχικοποιώ τους πίνακες B και C με τιμές που παρείχε ο χρήστης.
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                scanf("%d", &B[i][j]);  //Διαβάζω τις τιμές του χρήστη για τον πίνακα B[i][j]
            }
        }
        printf("Read Completed for Matrix B\n");

        printf("Please provide %d x %d Matrix C\n", N, N);
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                scanf("%d", &C[i][j]);  //Διαβάζω τις τιμές του χρήστη για τον πίνακα C[i][j]
            }
        }
        printf("Read Completed for Matrix C\n");
    }

    // Υπολογίζω τον βασικό αριθμό γραμμών που θα χειριστεί κάθε διεργασία
    // και καθορίζω εάν υπάρχουν επιπλέον γραμμές προς διανομή.
    int rows_per_process = N / num_procs; //Το N είναι ο συνολικός αριθμός γραμμών και το num_procs είναι ο συνολικός αριθμός των διεργασιών.
    int extra_rows = N % num_procs; // Υπολογίζω το υπόλοιπο της διαίρεσης, δηλαδή γραμμές που δεν διαιρούνται ομοιόμορφα μεταξύ των διεργασιών.
    int my_extra_row = 0; // Αρχικοποιώ την σημαία για να υποδείξω εάν η τρέχουσα διεργασία θα χειριστεί μια επιπλέον γραμμή.
    int my_rows = rows_per_process; // Εκχωρώ τον βασικό αριθμό γραμμών που θα χειριστεί κάθε διεργασία στο my_rows. 
    // Αυτό αντιπροσωπεύει τις γραμμές που έχουν αντιστοιχιστεί σε αυτήν τη διεργασία. 
    // Ενδέχεται να ενημερωθεί αργότερα στον κώδικα για να λαμβάνει υπόψη τυχόν επιπλέον γραμμές.


    // Η ριζική διεργασία μπορεί να λάβει πρόσθετες σειρές εάν το μέγεθος του πίνακα δεν διαιρείται ομοιόμορφα.
    if (my_rank == 0)
    {
        my_extra_row = extra_rows; // Εάν η τρέχουσα διεργασία είναι η ρίζα, τότε της εκχωρούνται οι επιπλέον γραμμές.
        my_rows += extra_rows; // Ενημερώστε τον συνολικό αριθμό γραμμών για τις οποίες είναι υπεύθυνη η ριζική διεργασία. 
        //Προσθέτω τις επιπλέον γραμμές στο αρχικό σύνολο γραμμών (my_rows), ώστε να συμπεριλάβω τις επιπλέον γραμμές.
    }


    // Εκχωρώ μνήμη για το υπομητώο στο οποίο θα λειτουργήσει κάθε διεργασία.
    // Οι διαστάσεις ποικίλλουν εάν η τρέχουσα διεργασία είναι η ρίζα και υπάρχουν επιπλέον γραμμές.
    int** BPart = createMatrix(my_rows, N); // Εκχωρώ μνήμη για το υπομητρώο B στο οποίο θα λειτουργήσει η τρέχουσα διεργασία. 
    int** APart = createMatrix(my_rows, N); // Ομοίως, εκχωρώ μνήμη για το υπομηρώο A που θα υπολογίσει η τρέχουσα διεργασία. 
    //Οι διαστάσεις είναι ίδιες με το Β.


    // Η ριζική διεργασία αντιγράφει τις επιπλέον γραμμές απευθείας στο υπομήτρώο (BPart).
    if (my_rank == 0)
    {
        for (int i = 0; i < extra_rows; i++) // Επαναλαμβάνεται στις επιπλέον γραμμές που δεν μπορούσαν να κατανεμηθούν ομοιόμορφα μεταξύ όλων των διεργασιών.
        {
            for (int j = 0; j < N; j++) // Επαναλαμβάνεται πάνω από κάθε στήλη του πίνακα.
            {
                BPart[i][j] = B[i][j]; // Αντιγράφω τις επιπλέον γραμμές απευθείας από τον πλήρη πίνακα B στο υπομητρώο BPart,
                //στο οποίο λειτουργεί η διεργασία ρίζας.

            }
        }
    }


    // Κατανέμω ομοιόμορφα τις υπόλοιπες γραμμές του πίνακα Β μεταξύ όλων των διεργασιών στον δακτύλιο.
    // Κάθε διεργασία λαμβάνει στοιχεία rows_per_process * N, τα οποία αποθηκεύει στον τοπικό της πίνακα BPart ξεκινώντας από το my_extra_row.
    // Αφού η διεργασία ρίζας πάρει το μερίδιό της από τα δεδομένα (τις επιπλέον γραμμές), αρχίζει να διανέμει τα υπόλοιπα δεδομένα (γραμμές) στις άλλες διεργασίες.
    /*
    &B[extra_rows][0]: Αυτή είναι η αρχική διεύθυνση των δεδομένων στη ριζική διεργάσία που θα διασκορπιστούν, ακριβώς μετά τις επιπλέον γραμμές. 
    rows_per_process * N: Αυτός είναι ο αριθμός των στοιχείων που πρέπει να σταλούν σε κάθε διεργασία. 
    Υπολογίζεται πολλαπλασιάζοντας τον αριθμό των γραμμών που πρέπει να χειρίζεται κάθε διεργασία (rows_per_process),
    με τον αριθμό των στηλών του πίνακα (N).
    MPI_INT: Υποδεικνύει τον τύπο των δεδομένων που αποστέλλονται και λαμβάνονται, που στην περίπτωση αυτή είναι ακέραιοι.
    &BPart[my_extra_row][0]: Αυτή είναι η διεύθυνση του buffer λήψης στις διεργασίες λήψης, όπου θα αποθηκευτούν τα διάσπαρτα δεδομένα.
    _ROOT: Αυτό είναι το rank της ριζικής διεργασίας στον επικοινωνητή, η οποία είναι υπεύθυνη για τη διασπορά των δεδομένων.
    ring_comm: Αυτός είναι ο communicator που ορίζει την ομάδα διεργασιών μεταξύ των οποίων θα διασκορπιστούν τα δεδομένα.
    */    
    MPI_Scatter(&B[extra_rows][0], rows_per_process * N, MPI_INT, &BPart[my_extra_row][0], rows_per_process * N, MPI_INT, _ROOT, ring_comm);



    // Μετάδοση ολόκληρου του πίνακα C (στέλνω το ίδιο τμήμα δεδομένων) σε όλες τις άλλες διεργασίες του δακτυλίου.  
    // Κάθε διεργασία χρειάζεται τον πλήρη πίνακα C για να εκτελέσει το μέρος του πολλαπλασιασμού της.
    /*
    &C[0][0]: Αυτή είναι η αρχική διεύθυνση του μηνύματος που θα μεταδοθεί, δηλαδή του πρώτου στοιχείου του πίνακα C.
    N * N: Αυτός είναι ο αριθμός των στοιχείων που θα σταλούν. Δεδομένου ότι ο C είναι ένας πίνακας μεγέθους N * N (πλήθος στοιχείων του πίνακα).
    MPI_INT: Υποδεικνύει τον τύπο των δεδομένων που αποστέλλονται, δηλαδή τα στοιχεία του πίνακα C είναι ακέραιοι.
    _ROOT: Το rank της ριζικής διεργασίας που μεταδίδει το μήνυμα. 
    ring_comm: Αυτός είναι ο communicator με τον οποίο πραγματοποιείται η εκπομπή. 
    */
    MPI_Bcast(&C[0][0], N * N, MPI_INT, _ROOT, ring_comm);


    // Κάθε διεργασία υπολογίζει το τμήμα του πολλαπλασιασμού του πίνακα που της έχει ανατεθεί.
    // Δηλαδή υπολογίζει το δικό της υπομητρώο APart, με βάση το τμήμα του πίνακα B (BPart) και τον πλήρη πίνακα C.
    for (int i = 0; i < my_rows; i++) //Επαναλαμβάνεται πάνω από τις γραμμές του πίνακα BPart που έχουν αντιστοιχιστεί στην τρέχουσα διεργασία. 
    {
        for (int j = 0; j < N; j++) // Επαναλαμβάνεται πάνω σε όλες τις στήλες των πινάκων.
        {
            int temp = 0; // Προσωρινή μεταβλητή για τη διατήρηση του αθροίσματος για το στοιχείο [i][j]
            for (int k = 0; k < N; k++)
            {
                temp += BPart[i][k] * C[k][j]; // Εκτελεί το εσωτερικό γινόμενο της γραμμής i του BPart με τη στήλης j του C.
            }
            APart[i][j] = temp; // Αποθηκεύω την υπολογισμένη τιμή του εσωτερικού γινομένου στο υπομητρώο APart.
        }
    }



    // Συγκεντρώνω τα υπολογισμένα υπομητρώα του A από όλες τις διεργασίες πίσω στη ρίζα.
    if (my_rank == _ROOT)
    {
        // Αντιγράφω τα αποτελέσματα από το APart στο A για τις επιπλέον γραμμές που χειρίστηκε η ριζική διεργασία.
        for (int i = 0; i < extra_rows; i++)
        {
            for (int j = 0; j < N; j++)
            {
                A[i][j] = APart[i][j];  // Αντιγράφω τις υπολογισμένες τιμές για τις επιπλέον γραμμές.
            }
        }
        
        // Μια διεργασία (root) συγκεντρώνει δεδομένα από όλες τις άλλες διεργασία εντός του ίδιου communicator.
        // Πρέπει να κληθεί από όλες τις διεργασίες με τα ίδια ορίσματα.
        // Συλλέγω τα υπολογισμένα υπομητρώα από όλες τις άλλες διεργασίες, ξεκινώντας αμέσως μετά τις επιπλέον γραμμές.
        /*
        &APart[extra_rows][0]: Αρχική διεύθυνση του buffer αποστολής.
        rows_per_process * N: Αυτός είναι ο αριθμός αποστολής, ο οποίος καθορίζει τον αριθμό των στοιχείων που θα σταλούν από κάθε διεργασία. 
        Υπολογίζεται ως ο αριθμός των γραμμών που χειρίζεται κάθε διεργασία επί τον αριθμό των στοιχείων ανά γραμμή (N).
        MPI_INT: Αυτός είναι ο τύπος δεδομένων αποστολής, που υποδεικνύει ότι τα στοιχεία που αποστέλλονται είναι ακέραιοι.
        &A[extra_rows][0]: Αυτή είναι η αρχική διεύθυνση του buffer λήψης στη διαδικασία ρίζας.
        rows_per_process * N: Πρόκειται για το πλήθος λήψεων, το οποίο είναι το ίδιο με το πλήθος αποστολής, προσδιορίζοντας τον αριθμό των στοιχείων που αναμένεται να ληφθούν ανά διεργασία.
        _ROOT: Rank της διεργασίας ρίζας στον επικοινωνιακό, ο οποίος θα λάβει τα συγκεντρωμένα δεδομένα.
        */
        MPI_Gather(&APart[extra_rows][0], rows_per_process * N, MPI_INT, &A[extra_rows][0], rows_per_process * N, MPI_INT, _ROOT, ring_comm);

       
    }
    else
    {
        // Οι μη ριζικές διεργασίες στέλνουν τα υπολογισμένα υπομητρώα τους στη ρίζα.
        /*
        APart[0]: Η αρχική διεύθυνση του buffer αποστολής (τα δεδομένα που στέλνει κάθε διεργασία).
        rows_per_process * N: Ο αριθμός των στοιχείων που αποστέλλονται από κάθε διεργασία.
        MPI_INT: Ο τύπος δεδομένων των στοιχείων που αποστέλλονται (στην περίπτωση αυτή, ακέραιοι).
        NULL: Δεδομένου ότι αυτή είναι μια διαδικασία που δεν έχει ρίζα, δεν έχει buffer λήψης, άρα NULL.
        rows_per_process * N: Ο αριθμός των στοιχείων που αναμένεται να ληφθούν από τη ριζική διεργασία από κάθε διαδικασία αποστολής.
        MPI_INT: Ο τύπος δεδομένων των στοιχείων που λαμβάνονται.
        _ROOT: Η κατάταξη της διαδικασίας ρίζας στο πρόγραμμα επικοινωνίας.
        ring_comm: Ο φορέας επικοινωνίας στον οποίο συλλέγονται τα δεδομένα.
        */
        MPI_Gather(APart[0], rows_per_process * N, MPI_INT, NULL, rows_per_process * N, MPI_INT, _ROOT, ring_comm);
       
    }



    // Η ριζική διεργασία γράφει τον τελικό πίνακα A σε αρχείο.
    if (my_rank == _ROOT)
    {

        //Ανοίγω το αρχείο OUT_FILE_NAME σε λειτουργία εγγραφής. 
        //Η fopen επιστρέφει έναν δείκτη τύπου FILE ο οποίος πρέπει να αποδοθεί στην μεταβλητή fout ίδιου τύπου,
        //αυτός ο τύπος προσδιορίζει το κανάλι επικοινωνίας και με την βοηθειά του αναφερόμαστε στο συγκεγκριμένο αρχείο.   
        FILE* fout = fopen(OUT_FILE_NAME, "w");
        
        //H fprintf εγγράφει στο αρχείο που καθορίζεται από το δείκτη fout τον πίνακα A και επιστρέφει τον αριθμό των χαρακτήρων που έγραψε στο αρχείο.
        fprintf(fout, "Matrix A:\n");
        for (int i = 0; i < N; i++) //Οι ένθετοι βρόχοι επαναλαμβάνονται σε ολόκληρο τον πίνακα A και κάθε κελί (i, j) στον πίνακα:
        {
            for (int j = 0; j < N; j++)
            {
                fprintf(fout, "%d ", A[i][j]); //Η τιμή του A[i][j] και ένα κενό μετά από την κάθε τιμή γράφονται στο αρχείο.
            }
            fprintf(fout, "\n"); //Αφού εγγράψω όλα τα στοιχεία σε μια γραμμή, προστίθεται ο χαρακτήρας αλλαγής γραμμής για να μετακινηθώ στην επόμενη γραμμή.
        }
        fclose(fout);
        //Κλείνω το αρχείο και μέσω της fclose γράφω στο αρχείο όλα τα δεδομένα που βρίσκονται στην περιοχή ενδιάμεσης αποθήκευσης (buffer),
        //πριν κλείσει το αρχείο. Καθώς όταν γράφω δεδομένα στο αρχείο αυτά καταχωρίζονται πρώτα στον buffer και όταν γεμίσει τότε
        //εγγράφονται πραγματικά στο αρχείο.

        printf("Matrix A written to file %s\n", OUT_FILE_NAME);

        //Εκτυπώνω το συνολικό χρόνο που χρειάζεται για τον υπολογισμό.
        printf("Total time taken: %g secs\n", MPI_Wtime() - startTime);
    }

    //Ελευθερώνω την εκχωρημένη μνήμη για τους πίνακες B, C και των τμημάτων τους.
    free(B[0]); //Ελευθερώνω το συνεχόμενο μπλοκ μνήμης για τον πίνακα Β.
    free(B);    //Ελευθερώνω τον πίνακα δεικτών για τον πίνακα Β.
    free(BPart[0]); //Ελευθερώνω το συνεχόμενο μπλοκ μνήμης για το τοπικό τμήμα του πίνακα Β.
    free(BPart); //Ελευθερώνω τον πίνακα δεικτών για το τοπικό τμήμα του πίνακα Β.
    free(C[0]); //Ελευθερώνω το συνεχόμενο μπλοκ μνήμης για τον πίνακα C.
    free(C); //Ελευθερώνω τον πίνακα δεικτών για τον πίνακα C.


    //Εάν η τρέχουσα διεργασία είναι η ρίζα, ελευθερώνω επίσης τη μνήμη που έχει εκχωρηθεί για τον πλήρη πίνακα A και το τμήμα του, εάν υπάρχει.
    if (new_rank == _ROOT) {
        free(A[0]); //Ελευθερώνω το συνεχόμενο μπλοκ μνήμης για τον πίνακα A.
        free(A);    //Ελευθερώνω τον πίνακα δεικτών για τον πίνακα Α.
    }
    free(APart[0]); //Ελευθερώνω το συνεχόμενο μπλοκ μνήμης για το τοπικό τμήμα του πίνακα A.
    free(APart);    //Ελευθερώνω τον πίνακα δεικτών για το τοπικό τμήμα του πίνακα A.

    //Τερματίζω τον υπολογισμό και κάνω εκαθάριση στην χρησιμοποιούμενη υλοποίηση.
    //H MPI_Finalize πρέπει να καλέιται από κάθε διεργασία MPI ακριβώς μια φορά.
    MPI_Finalize();
    return 0;
}
